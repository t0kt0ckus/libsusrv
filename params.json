{"name":"Libsusrv","tagline":"A simple native Android SU client library.","body":"libsusrv\r\n=\r\n\r\nA simple native Android SU client library.\r\n\r\nThis library provides priviledged shell sessions on any Android system where a suitable SU application is installed.\r\n\r\nThis library:\r\n- forks a single SU Shell child process per Android application, with which it then communicates through a local UNIX socket \r\n- permits to execute Shell *command strings*, where a *command string* may be a *Simple Command*, a *Pipeline*, a *List* or a *Compound Command*, as specified by the relevant man page\r\n- permits access to the exit code returned by the command string \r\n- permits access to what would be the output produced on a controlling terminal\r\n- executes the command strings in the order they are submitted\r\n- is accessible from both native C and Java code\r\n\r\n**Note:** This primarily comprises a native shared library (`libsusrv.so`) for any considered architecture, and the definition of a Java object (`org.openmarl.susrv.LibSusrv`) that publishes the JNI-exported API. These components are standard POSIX/JNI stuff and may be used in a non Android context.\r\n\r\n**Disclaimer:** Great documentation and examples, targeted to developers that need to integrate priviledged commands execution from an Android application, are maintained by Chainfire at [libsuperuser](https://github.com/Chainfire/libsuperuser). The `libsuperuser` library available there may offer more features and be more flexible than this one. I've written this simple trick because I feel it better suits my present requirements, and I share this code here. I also admit that the choice of a native library may not provide any sensible performance benefit in most situations, this wasn't a motivation here.\r\n\r\n**License**\r\n\r\n```\r\nt0kt0ckus@gmail.com\r\n(C) 2014\r\n\r\nThis program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n```\r\n\r\nRequirements\r\n===\r\n\r\nRequirements are obvious:\r\n- A rooted Android device, with an installed SU application, that is an application that provides a `su` binary that can spawn priviledged shell sessions. The library will search into the following directories: `/sbin`, `/system/sbin`, `/system/bin`, and `/system/xbin`, in that order.\r\n- The native implementation relies upon POSIX C APIs, implemented in bionic, and should apply to most of Android OS versions.\r\n\r\nThe library seems to work fine with Chainfire's [SuperSU](http://www.chainfire.eu/projects/52/SuperSU/) on Android KitKat 4.x.  \r\n\r\n\r\nOverview\r\n===\r\n\r\nAccording to Chainfire's [How-To SU](http://su.chainfire.eu/), in order to support most of the wildely adopted SU applications, and to avoid spawning an ephemeral `su` process upon each command string execution, we may choose to fork a single shell, to which we'll write command strings, and from which we'll read back what would be the output produced on a controlling terminal.\r\n\r\nThis is implemented through native POSIX primitives, and as such, a Shell session comprises:\r\n- a running `su` child process\r\n- a local UNIX socket to communicate with\r\n- a thread that consumes and interpret the socket I/O\r\n- mutexes to synchronize things\r\n \r\nAnd the API is very simple:\r\n- an `init()` call, that initializes a session as described above\r\n- an `exec()` call, that permits to execute command strings, blocking untill the command exit code is available\r\n- an `exit()` call, that terminates the shell process and releases the session resources\r\n\r\nThough the library's implementation allows client code to use threads to *queue* command strings, preserving order of submit, keep in mind that there's a unique shell child process per Android application to execute these commands.\r\n\r\n(Technicaly, one child SU shell may exist per process that loads the `libsusrv.so` shared library.)\r\n\r\nA SU shell session opens two files:\r\n- `<app-dir>/var/log/su_session-<pid>.log`: contains some debug information and what would be the output produced on a controlling terminal\r\n- `<app-dir>/var/run/su_session-<pid>`: which is the UNIX address `sun_path` of the rendez-vous socket, that will be unlinked as soon as the client peer connection to the shell process is established or denied, so it should be ephemeral\r\n\r\nwhere `<app-dir>` is the root of the embedding application private filesystem as answered by `android.content.Context.getFilesDir().getPath()`, usually `/data/data/<application-package>/files`.\r\n\r\n\r\nBuild\r\n===\r\n\r\nObvisouly, both Android SDK and NDK must be installed, and the `ANDROID_SDK` and `ANDROID_NDK` environment variables propertly set.\r\n\r\nTo build a library archive for all architectures:\r\n```\r\n$ git clone https://github.com/t0kt0ckus/libsusrv.git\r\n$ cd libsusrv\r\n$ ./make.sh \r\n[armeabi-v7a] Compile thumb  : susrv <= su_srv.c\r\n[armeabi-v7a] Compile thumb  : susrv <= su_srv_jni.c\r\n[armeabi-v7a] Compile thumb  : susrv <= su_srv_log.c\r\n[armeabi-v7a] Compile thumb  : susrv <= su_srv_pfs.c\r\n[armeabi-v7a] Compile thumb  : susrv <= su_shell_session.c\r\n[armeabi-v7a] SharedLibrary  : libsusrv.so\r\n[armeabi-v7a] Install        : libsusrv.so => libs/armeabi-v7a/libsusrv.so\r\n[armeabi] Compile thumb  : susrv <= su_srv.c\r\n[armeabi] Compile thumb  : susrv <= su_srv_jni.c\r\n[armeabi] Compile thumb  : susrv <= su_srv_log.c\r\n[armeabi] Compile thumb  : susrv <= su_srv_pfs.c\r\n[armeabi] Compile thumb  : susrv <= su_shell_session.c\r\n[armeabi] SharedLibrary  : libsusrv.so\r\n[armeabi] Install        : libsusrv.so => libs/armeabi/libsusrv.so\r\n[x86] Compile        : susrv <= su_srv.c\r\n[x86] Compile        : susrv <= su_srv_jni.c\r\n[x86] Compile        : susrv <= su_srv_log.c\r\n[x86] Compile        : susrv <= su_srv_pfs.c\r\n[x86] Compile        : susrv <= su_shell_session.c\r\n[x86] SharedLibrary  : libsusrv.so\r\n[x86] Install        : libsusrv.so => libs/x86/libsusrv.so\r\n[mips] Compile        : susrv <= su_srv.c\r\n[mips] Compile        : susrv <= su_srv_jni.c\r\n[mips] Compile        : susrv <= su_srv_log.c\r\n[mips] Compile        : susrv <= su_srv_pfs.c\r\n[mips] Compile        : susrv <= su_shell_session.c\r\n[mips] SharedLibrary  : libsusrv.so\r\n[mips] Install        : libsusrv.so => libs/mips/libsusrv.so\r\n  adding: org/openmarl/susrv/SuShell.class (deflated 47%)\r\n  adding: org/openmarl/susrv/LibSusrv.class (deflated 37%)\r\n  adding: org/openmarl/susrv/SuShellAsyncInit.class (deflated 49%)\r\n  adding: org/openmarl/susrv/SuShellAsyncObserver.class (deflated 25%)\r\n  adding: org/openmarl/susrv/SuSrvException.class (deflated 43%)\r\n  adding: lib/armeabi/libsusrv.so (deflated 58%)\r\n  adding: lib/armeabi-v7a/libsusrv.so (deflated 58%)\r\n  adding: lib/mips/libsusrv.so (deflated 91%)\r\n  adding: lib/x86/libsusrv.so (deflated 63%)\r\nMulti-arch library archive: /marl/git/t0kt0ckus/libsusrv/dist/libsusrv.jar  \r\n```\r\n\r\nThe produced  `dist/libsusrv.jar` contains:\r\n```\r\n// The native shared libraries\r\n//\r\n+ lib/armeabi/libsusrv.so\r\n+ lib/armeabi-v7a/libsusrv.so\r\n+ lib/mips/libsusrv.so\r\n+ lib/x86/libsusrv.so\r\n\r\n// The JNI object that publishes the native API\r\n//\r\n+ org/openmarl/susrv/LibSusrv.class\r\n\r\n// Some Android specific more friendly API\r\n//\r\n+ org/openmarl/susrv/SuShell.class\r\n+ org/openmarl/susrv/SuShellAsyncInit.class\r\n+ org/openmarl/susrv/SuShellAsyncObserver.class\r\n+ org/openmarl/susrv/NoShellSessionError.class\r\n```\r\n\r\nThis script also generates the Java API documentation to the `dist/api` directory. And `dist/include` will show the relevant C headers. \r\n\r\nAs the actual build configuration is defined through `Android.mk` and `Applciation.mk`, one may also invoke directly the NDK tools as she uses to.\r\nA standard `Makefile` is also given, that help building the shared library to target a non Android context.\r\n\r\nDeveloper's guide\r\n===\r\n\r\nWe'll detail bellow the Android application developer's point of view. \r\n\r\n**Installation**\r\n\r\nTo make both the native shared library and the Java API available, one have to:\r\n- build a suitable JAR archive, for example using the provided `make.sh` script\r\n- copy this file (`libsusrv.jar`) to the `libs` directory of the Android application (this actual location depends upon the development tools chain)\r\n\r\nThe Java API package is `org.openmarl.susrv`.\r\n\r\n**Session initialization**\r\n\r\nInitialization is initiated by a call to the `SuShell.getInstance(context)` static method, which return a `SuShell` instance on success. The native SU shell session represented by this object is then bound to the requesting process.\r\n\r\nKeeping a reference to this instance may be a good idea, though any further call to `SuShell.getInstance(null)` will immediately returns the currently bound SU shell session, without any overhead.\r\n\r\nInitialization should not occur on the main thread, as the SU shell child process creation may take some time. Instead, have an activity that implement `SuShellAsyncObserver`, and starts an `SuShellAsyncInit` async task from some appropriate point of its life-cycle.\r\n\r\n**Executing commands**\r\n\r\nAny valid *command string* may be executed using the blocking API call:\r\n```java\r\nint rval =  SuShell.getInstance(null).exec(cmd);\r\n```\r\nwhere `rval` is the integer exit code of the command execution sub-process, as returned by `echo $?`. \r\n\r\nIf the shell session has not been initialized or has been invalidated, a `NoShellSessionError` exception is thrown.\r\n\r\nCommand strings execution may be queued by wrapping `exec()` calls within distinct threads: commands will then execute in the order they have been submitted, and each thread will have the appropriate return value delivered.\r\n\r\n**Session termination**\r\n\r\nA session is invalidated either normaly when `SuShell.exit()` is called, or when the child shell process terminates abnormally. In both situations, one can safely initiate a new session by calling `SuShell.getInstance(context)` again.\r\n\r\n\r\nExample\r\n===\r\n\r\nThis example is available in the `org.openmarl.susrv.example` package.\r\n\r\n\r\nWe consider an activity like bellow:\r\n\r\n```java\r\npublic class SomeActivity extends Activity implements SuShellAsyncObserver {\r\n\r\n    private SuShell mSuShell;\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_home);\r\n\r\n        new SuShellAsyncInit(this).execute();\r\n    }\r\n    \r\n    @Override\r\n    protected void onDestroy() {\r\n        super.onDestroy();\r\n        if (mSuShell != null) {\r\n            mSuShell.exit();\r\n            mSuShell = null;\r\n        }\r\n    }\r\n    \r\n    @Override\r\n    public void onShellInitComplete(SuShell suShell) {\r\n        mSuShell = suShell;\r\n\r\n        if (mSuShell != null) {\r\n            Log.d(TAG, \"SU shell session successfully initialized\");\r\n            try {\r\n                int rval = mSuShell.exec(\"id\"); // rval will have the value 0\r\n            }\r\n            catch(NoShellSessionError e) {\r\n                mSuShell = null;\r\n                Log.w(TAG, \"SU shell session has just been invalidated, no luck\");\r\n            }\r\n        }\r\n        else\r\n            Log.e(TAG, \"Failed to initialize SU shell session\");\r\n    }\r\n}\r\n```\r\n\r\nThis will produce the log file bellow:\r\n```\r\nroot@falcon_umts:/ # cat /data/data/org.openmarl.susrvexample/files/var/log/su_session-10729.log\r\n[su_srv] Initializing SU shell session:\r\n[su_srv] owner PID: 10729\r\n[su_srv] AF UNIX path: /data/data/org.openmarl.susrvexample/files/var/run/su_session-10729\r\n[su_srv] AF UNIX rendez-vous complete\r\n[su_srv] Found system SU binary: /system/xbin/su\r\n[su_srv] Created SU shell child process (PID: 10753)\r\n[su_srv] SU shell session initialization complete\r\n# id\r\nuid=0(root) gid=0(root) context=u:r:init:s0\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}